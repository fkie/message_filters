<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>FKIE Message Filters: fkie_message_filters::Buffer&lt; Inputs &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">FKIE Message Filters
   </div>
   <div id="projectbrief">Improved filters for processing ROS messages</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacefkie__message__filters.html">fkie_message_filters</a></li><li class="navelem"><a class="el" href="classfkie__message__filters_1_1Buffer.html">Buffer</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classfkie__message__filters_1_1Buffer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">fkie_message_filters::Buffer&lt; Inputs &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Store and forward data.  
 <a href="classfkie__message__filters_1_1Buffer.html#details">More...</a></p>

<p><code>#include &lt;fkie_message_filters/buffer.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for fkie_message_filters::Buffer&lt; Inputs &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classfkie__message__filters_1_1Buffer__inherit__graph.png" border="0" usemap="#fkie__message__filters_1_1Buffer_3_01Inputs_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="fkie__message__filters_1_1Buffer_3_01Inputs_01_4_inherit__map" id="fkie__message__filters_1_1Buffer_3_01Inputs_01_4_inherit__map">
<area shape="rect" id="node2" href="classfkie__message__filters_1_1Filter.html" title="fkie_message_filters\l::Filter\&lt; IO\&lt; Inputs...\l \&gt;, IO\&lt; Inputs... \&gt; \&gt;" alt="" coords="425,31,571,87"/>
<area shape="rect" id="node3" href="classfkie__message__filters_1_1Sink.html" title="Base class for data consumers. " alt="" coords="203,5,370,47"/>
<area shape="rect" id="node4" href="classfkie__message__filters_1_1FilterBase.html" title="Base class for filters. " alt="" coords="5,39,148,80"/>
<area shape="rect" id="node5" href="classfkie__message__filters_1_1Source.html" title="fkie_message_filters\l::Source\&lt; IO\&lt; Inputs... \&gt; \&gt;" alt="" coords="196,71,377,112"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for fkie_message_filters::Buffer&lt; Inputs &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classfkie__message__filters_1_1Buffer__coll__graph.png" border="0" usemap="#fkie__message__filters_1_1Buffer_3_01Inputs_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="fkie__message__filters_1_1Buffer_3_01Inputs_01_4_coll__map" id="fkie__message__filters_1_1Buffer_3_01Inputs_01_4_coll__map">
<area shape="rect" id="node2" href="classfkie__message__filters_1_1Filter.html" title="fkie_message_filters\l::Filter\&lt; IO\&lt; Inputs...\l \&gt;, IO\&lt; Inputs... \&gt; \&gt;" alt="" coords="425,31,571,87"/>
<area shape="rect" id="node3" href="classfkie__message__filters_1_1Sink.html" title="Base class for data consumers. " alt="" coords="203,5,370,47"/>
<area shape="rect" id="node4" href="classfkie__message__filters_1_1FilterBase.html" title="Base class for filters. " alt="" coords="5,39,148,80"/>
<area shape="rect" id="node5" href="classfkie__message__filters_1_1Source.html" title="fkie_message_filters\l::Source\&lt; IO\&lt; Inputs... \&gt; \&gt;" alt="" coords="196,71,377,112"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a0f68fa081ebeca7074f24306762002f3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfkie__message__filters_1_1Sink.html#a0f68fa081ebeca7074f24306762002f3">Input</a> = <a class="el" href="classfkie__message__filters_1_1IO.html">IO</a>&lt; Inputs... &gt;</td></tr>
<tr class="memdesc:a0f68fa081ebeca7074f24306762002f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Grouped input types.  <a href="#a0f68fa081ebeca7074f24306762002f3">More...</a><br /></td></tr>
<tr class="separator:a0f68fa081ebeca7074f24306762002f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf62f81139581703a6fbe41dd3e9d579"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfkie__message__filters_1_1Source.html#abf62f81139581703a6fbe41dd3e9d579">Output</a> = <a class="el" href="classfkie__message__filters_1_1IO.html">IO</a>&lt; Outputs... &gt;</td></tr>
<tr class="memdesc:abf62f81139581703a6fbe41dd3e9d579"><td class="mdescLeft">&#160;</td><td class="mdescRight">Grouped output types.  <a href="#abf62f81139581703a6fbe41dd3e9d579">More...</a><br /></td></tr>
<tr class="separator:abf62f81139581703a6fbe41dd3e9d579"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:afb36798903ca5872608ffc19fe7d2ce7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfkie__message__filters_1_1Buffer.html#afb36798903ca5872608ffc19fe7d2ce7">Buffer</a> (const ros::NodeHandle &amp;nh, std::size_t max_queue_size) noexcept</td></tr>
<tr class="memdesc:afb36798903ca5872608ffc19fe7d2ce7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#afb36798903ca5872608ffc19fe7d2ce7">More...</a><br /></td></tr>
<tr class="separator:afb36798903ca5872608ffc19fe7d2ce7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eaf002b3ff5fe7818056a1f900a24e2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfkie__message__filters_1_1Buffer.html#a0eaf002b3ff5fe7818056a1f900a24e2">Buffer</a> (<a class="el" href="namespacefkie__message__filters.html#aa9578ad344a317def3fbb4850a67ea89">BufferPolicy</a> policy=<a class="el" href="namespacefkie__message__filters.html#aa9578ad344a317def3fbb4850a67ea89ad94b42030b9785fd754d5c1754961269">BufferPolicy::Discard</a>, std::size_t max_queue_size=1, ros::CallbackQueueInterface *cbq=nullptr) noexcept</td></tr>
<tr class="memdesc:a0eaf002b3ff5fe7818056a1f900a24e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#a0eaf002b3ff5fe7818056a1f900a24e2">More...</a><br /></td></tr>
<tr class="separator:a0eaf002b3ff5fe7818056a1f900a24e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a831b68e0dfab4aa7164f2281ae566b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacefkie__message__filters.html#a3df68948f3719ec5ab09f1191fc89a7b">Connection</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfkie__message__filters_1_1Source.html#a1a831b68e0dfab4aa7164f2281ae566b">connect_to_sink</a> (<a class="el" href="classfkie__message__filters_1_1Sink.html">Sink</a>&lt; Outputs... &gt; &amp;dst) noexcept</td></tr>
<tr class="memdesc:a1a831b68e0dfab4aa7164f2281ae566b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect this source to a sink.  <a href="#a1a831b68e0dfab4aa7164f2281ae566b">More...</a><br /></td></tr>
<tr class="separator:a1a831b68e0dfab4aa7164f2281ae566b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6f66493ea85a32a0c44f33d7a51974e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacefkie__message__filters.html#a3df68948f3719ec5ab09f1191fc89a7b">Connection</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfkie__message__filters_1_1Sink.html#ab6f66493ea85a32a0c44f33d7a51974e">connect_to_source</a> (<a class="el" href="classfkie__message__filters_1_1Source.html">Source</a>&lt; Inputs... &gt; &amp;src) noexcept</td></tr>
<tr class="memdesc:ab6f66493ea85a32a0c44f33d7a51974e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect this sink to a source.  <a href="#ab6f66493ea85a32a0c44f33d7a51974e">More...</a><br /></td></tr>
<tr class="separator:ab6f66493ea85a32a0c44f33d7a51974e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add3cbfc888cca3b41a7236f5c314fc43"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfkie__message__filters_1_1Source.html#add3cbfc888cca3b41a7236f5c314fc43">disconnect_from_all_sinks</a> () noexcept</td></tr>
<tr class="memdesc:add3cbfc888cca3b41a7236f5c314fc43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnect from all connected sinks.  <a href="#add3cbfc888cca3b41a7236f5c314fc43">More...</a><br /></td></tr>
<tr class="separator:add3cbfc888cca3b41a7236f5c314fc43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2c8d910b03662ff68a4a1c9b4be4147"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfkie__message__filters_1_1Sink.html#ac2c8d910b03662ff68a4a1c9b4be4147">disconnect_from_all_sources</a> () noexcept</td></tr>
<tr class="memdesc:ac2c8d910b03662ff68a4a1c9b4be4147"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnect from all connected sources.  <a href="#ac2c8d910b03662ff68a4a1c9b4be4147">More...</a><br /></td></tr>
<tr class="separator:ac2c8d910b03662ff68a4a1c9b4be4147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61d7ea782d7d4390f7b6ae4fecc4ecde"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfkie__message__filters_1_1Buffer.html#a61d7ea782d7d4390f7b6ae4fecc4ecde">has_some</a> () const noexcept</td></tr>
<tr class="memdesc:a61d7ea782d7d4390f7b6ae4fecc4ecde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the buffer has pending data.  <a href="#a61d7ea782d7d4390f7b6ae4fecc4ecde">More...</a><br /></td></tr>
<tr class="separator:a61d7ea782d7d4390f7b6ae4fecc4ecde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d40121fca917642f806117b4b5ef6ca"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfkie__message__filters_1_1Buffer.html#a7d40121fca917642f806117b4b5ef6ca">process_one</a> ()</td></tr>
<tr class="memdesc:a7d40121fca917642f806117b4b5ef6ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for and process one data item.  <a href="#a7d40121fca917642f806117b4b5ef6ca">More...</a><br /></td></tr>
<tr class="separator:a7d40121fca917642f806117b4b5ef6ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acac65c45b3ac0413e3f21d5a293b1331"><td class="memTemplParams" colspan="2">template&lt;class Rep , class Period &gt; </td></tr>
<tr class="memitem:acac65c45b3ac0413e3f21d5a293b1331"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classfkie__message__filters_1_1Buffer.html#acac65c45b3ac0413e3f21d5a293b1331">process_one</a> (const std::chrono::duration&lt; Rep, Period &gt; &amp;timeout)</td></tr>
<tr class="memdesc:acac65c45b3ac0413e3f21d5a293b1331"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for and process one data item.  <a href="#acac65c45b3ac0413e3f21d5a293b1331">More...</a><br /></td></tr>
<tr class="separator:acac65c45b3ac0413e3f21d5a293b1331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55b6e088784aa02b6efec16ad1348955"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfkie__message__filters_1_1Buffer.html#a55b6e088784aa02b6efec16ad1348955">reset</a> () noexcept override</td></tr>
<tr class="memdesc:a55b6e088784aa02b6efec16ad1348955"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset filter.  <a href="#a55b6e088784aa02b6efec16ad1348955">More...</a><br /></td></tr>
<tr class="separator:a55b6e088784aa02b6efec16ad1348955"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a442730021f44627cd5c7e3ea05a0d7d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfkie__message__filters_1_1Buffer.html#a442730021f44627cd5c7e3ea05a0d7d5">set_callback_queue</a> (ros::CallbackQueueInterface *cbq) noexcept</td></tr>
<tr class="memdesc:a442730021f44627cd5c7e3ea05a0d7d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process data with a ROS callback queue.  <a href="#a442730021f44627cd5c7e3ea05a0d7d5">More...</a><br /></td></tr>
<tr class="separator:a442730021f44627cd5c7e3ea05a0d7d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa57fd09ab96b5b322ad43c6d2813dc5f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfkie__message__filters_1_1Buffer.html#aa57fd09ab96b5b322ad43c6d2813dc5f">set_policy</a> (<a class="el" href="namespacefkie__message__filters.html#aa9578ad344a317def3fbb4850a67ea89">BufferPolicy</a> policy, std::size_t max_queue_size=0)</td></tr>
<tr class="memdesc:aa57fd09ab96b5b322ad43c6d2813dc5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify the buffer policy.  <a href="#aa57fd09ab96b5b322ad43c6d2813dc5f">More...</a><br /></td></tr>
<tr class="separator:aa57fd09ab96b5b322ad43c6d2813dc5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e73957be1c2d7f2223206d189d8669f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfkie__message__filters_1_1Buffer.html#a4e73957be1c2d7f2223206d189d8669f">spin</a> ()</td></tr>
<tr class="memdesc:a4e73957be1c2d7f2223206d189d8669f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process all data indefinitely.  <a href="#a4e73957be1c2d7f2223206d189d8669f">More...</a><br /></td></tr>
<tr class="separator:a4e73957be1c2d7f2223206d189d8669f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbabc3c79481b303af00f348c760bba1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfkie__message__filters_1_1Buffer.html#afbabc3c79481b303af00f348c760bba1">spin_once</a> ()</td></tr>
<tr class="memdesc:afbabc3c79481b303af00f348c760bba1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process pending data.  <a href="#afbabc3c79481b303af00f348c760bba1">More...</a><br /></td></tr>
<tr class="separator:afbabc3c79481b303af00f348c760bba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08a7892ed0a8602685fb6453be134ac6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfkie__message__filters_1_1Buffer.html#a08a7892ed0a8602685fb6453be134ac6">wait</a> () noexcept</td></tr>
<tr class="memdesc:a08a7892ed0a8602685fb6453be134ac6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for pending data.  <a href="#a08a7892ed0a8602685fb6453be134ac6">More...</a><br /></td></tr>
<tr class="separator:a08a7892ed0a8602685fb6453be134ac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adde77088d53cd1d6de70840e10532658"><td class="memTemplParams" colspan="2">template&lt;class Rep , class Period &gt; </td></tr>
<tr class="memitem:adde77088d53cd1d6de70840e10532658"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classfkie__message__filters_1_1Buffer.html#adde77088d53cd1d6de70840e10532658">wait_for</a> (const std::chrono::duration&lt; Rep, Period &gt; &amp;timeout) noexcept</td></tr>
<tr class="memdesc:adde77088d53cd1d6de70840e10532658"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for pending data until timeout expires.  <a href="#adde77088d53cd1d6de70840e10532658">More...</a><br /></td></tr>
<tr class="separator:adde77088d53cd1d6de70840e10532658"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a6c006700f85dee1fd531d268630aa006"><td class="memItemLeft" align="right" valign="top"><a id="a6c006700f85dee1fd531d268630aa006"></a>
static constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfkie__message__filters_1_1Sink.html#a6c006700f85dee1fd531d268630aa006">NUM_INPUTS</a> = sizeof...(Inputs)</td></tr>
<tr class="memdesc:a6c006700f85dee1fd531d268630aa006"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of input arguments. <br /></td></tr>
<tr class="separator:a6c006700f85dee1fd531d268630aa006"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af49e2493417d30e42db4e98ac37aaa93"><td class="memItemLeft" align="right" valign="top"><a id="af49e2493417d30e42db4e98ac37aaa93"></a>
static constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfkie__message__filters_1_1Source.html#af49e2493417d30e42db4e98ac37aaa93">NUM_OUTPUTS</a></td></tr>
<tr class="memdesc:af49e2493417d30e42db4e98ac37aaa93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of output arguments. <br /></td></tr>
<tr class="separator:af49e2493417d30e42db4e98ac37aaa93"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a0c92512a4e975c949255eada0ce387c2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfkie__message__filters_1_1Buffer.html#a0c92512a4e975c949255eada0ce387c2">receive</a> (const Inputs &amp;... in) override</td></tr>
<tr class="memdesc:a0c92512a4e975c949255eada0ce387c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process incoming data.  <a href="#a0c92512a4e975c949255eada0ce387c2">More...</a><br /></td></tr>
<tr class="separator:a0c92512a4e975c949255eada0ce387c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a506e87b830bb228995e42f72a4daf5d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfkie__message__filters_1_1Source.html#a506e87b830bb228995e42f72a4daf5d9">send</a> (const Outputs &amp;... out)</td></tr>
<tr class="memdesc:a506e87b830bb228995e42f72a4daf5d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pass data to all connected sinks.  <a href="#a506e87b830bb228995e42f72a4daf5d9">More...</a><br /></td></tr>
<tr class="separator:a506e87b830bb228995e42f72a4daf5d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class... Inputs&gt;<br />
class fkie_message_filters::Buffer&lt; Inputs &gt;</h3>

<p>Store and forward data. </p>
<p>The buffer acts as a decoupler in the filter pipeline. Data can be stored and processed at a later time. The pipeline is effectively split into independent upstream and downstream parts, and it becomes possible to run the downstream data processing asynchronously. For instance, you can run computationally expensive algorithms on ROS messages in a different thread without blocking the ROS subscriber callback queue.</p>
<p>The buffer can be used for at least three different use cases:</p><ol type="1">
<li><b>Use the buffer as a valve</b><br />
 You can toggle between the <a class="el" href="namespacefkie__message__filters.html#aa9578ad344a317def3fbb4850a67ea89ad94b42030b9785fd754d5c1754961269" title="Discard all data. ">BufferPolicy::Discard</a> and <a class="el" href="namespacefkie__message__filters.html#aa9578ad344a317def3fbb4850a67ea89ac3e72e91fe05fe792fa27eea830ec68f" title="Forward data immediately. ">BufferPolicy::Passthru</a> modes to selectively disable or enable data processing at specific times. This is the simplest use case without any asynchronous processing.</li>
<li><b>Run multiple ROS callback queues</b><br />
 If your ROS node runs multiple callback queues, you can use the buffer to bind processing to a particular queue: <div class="fragment"><div class="line"><span class="keyword">namespace </span>mf = <a class="code" href="namespacefkie__message__filters.html">fkie_message_filters</a>;</div><div class="line"></div><div class="line">ros::NodeHandle nh;</div><div class="line">nh.setCallbackQueue(...);</div><div class="line"></div><div class="line"><span class="comment">// Version 1</span></div><div class="line">mf::Buffer&lt;M&gt; buf1(nh, 10);  <span class="comment">// will use the callback queue of nh</span></div><div class="line"></div><div class="line"><span class="comment">// Version 2</span></div><div class="line">mf::Buffer&lt;M&gt; buf2(mf::BufferPolicy::Queue, 10);</div><div class="line">buf2.set_callback_queue(...); <span class="comment">// will explicitly set the ROS callback queue</span></div></div><!-- fragment --></li>
<li><b>Run your own thread(s) for data processing</b><br />
 This is the most versatile option for advanced users. You can set up your worker threads as you desire and then call <a class="el" href="classfkie__message__filters_1_1Buffer.html#a4e73957be1c2d7f2223206d189d8669f" title="Process all data indefinitely. ">spin()</a>, <a class="el" href="classfkie__message__filters_1_1Buffer.html#afbabc3c79481b303af00f348c760bba1" title="Process pending data. ">spin_once()</a> or <a class="el" href="classfkie__message__filters_1_1Buffer.html#a7d40121fca917642f806117b4b5ef6ca" title="Wait for and process one data item. ">process_one()</a> as you see fit. <div class="fragment"><div class="line"><span class="keyword">namespace </span>mf = <a class="code" href="namespacefkie__message__filters.html">fkie_message_filters</a>;</div><div class="line"></div><div class="line">mf::Subscriber&lt;M&gt; sub;</div><div class="line">mf::Buffer&lt;mf::Subscriber&lt;M&gt;::Output&gt; buffer(mf::BufferPolicy::Queue, 10);</div><div class="line">mf::SimpleUserFilter&lt;mf::Subscriber&lt;M&gt;::Output&gt; flt;</div><div class="line"></div><div class="line">std::thread t([&amp;buffer]{ buffer.spin(); });</div><div class="line">flt.set_processing_function(...);</div><div class="line">mf::chain(sub, buffer, flt);</div><div class="line">ros::spin();</div></div><!-- fragment --> </li>
</ol>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a0f68fa081ebeca7074f24306762002f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f68fa081ebeca7074f24306762002f3">&#9670;&nbsp;</a></span>Input</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Inputs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classfkie__message__filters_1_1Sink.html">fkie_message_filters::Sink</a>&lt; Inputs &gt;::<a class="el" href="classfkie__message__filters_1_1Sink.html#a0f68fa081ebeca7074f24306762002f3">Input</a> =  <a class="el" href="classfkie__message__filters_1_1IO.html">IO</a>&lt;Inputs...&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Grouped input types. </p>
<p>This type can be used to define sources with matching types. </p>

</div>
</div>
<a id="abf62f81139581703a6fbe41dd3e9d579"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf62f81139581703a6fbe41dd3e9d579">&#9670;&nbsp;</a></span>Output</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classfkie__message__filters_1_1Source.html">fkie_message_filters::Source</a>&lt; Outputs &gt;::<a class="el" href="classfkie__message__filters_1_1Source.html#abf62f81139581703a6fbe41dd3e9d579">Output</a> =  <a class="el" href="classfkie__message__filters_1_1IO.html">IO</a>&lt;Outputs...&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Grouped output types. </p>
<p>This type can be used to define sinks with matching types. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="afb36798903ca5872608ffc19fe7d2ce7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb36798903ca5872608ffc19fe7d2ce7">&#9670;&nbsp;</a></span>Buffer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... Inputs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfkie__message__filters_1_1Buffer.html">fkie_message_filters::Buffer</a>&lt; Inputs &gt;::<a class="el" href="classfkie__message__filters_1_1Buffer.html">Buffer</a> </td>
          <td>(</td>
          <td class="paramtype">const ros::NodeHandle &amp;&#160;</td>
          <td class="paramname"><em>nh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>max_queue_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<p>Constructs a buffer with <a class="el" href="namespacefkie__message__filters.html#aa9578ad344a317def3fbb4850a67ea89a722ad2d05ecf4868b00c5484b82fd808" title="Queue for later use. ">BufferPolicy::Queue</a> policy and data processing via ROS callbacks.</p>
<ul>
<li><code>nh</code> ROS node handle whose callback queue is used for data processing </li>
<li><code>max_queue_size</code> the maximum number of queued data items</li>
</ul>
<dl class="section user"><dt>Exceptions</dt><dd>Does not throw any exceptions. </dd></dl>

</div>
</div>
<a id="a0eaf002b3ff5fe7818056a1f900a24e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0eaf002b3ff5fe7818056a1f900a24e2">&#9670;&nbsp;</a></span>Buffer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... Inputs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfkie__message__filters_1_1Buffer.html">fkie_message_filters::Buffer</a>&lt; Inputs &gt;::<a class="el" href="classfkie__message__filters_1_1Buffer.html">Buffer</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacefkie__message__filters.html#aa9578ad344a317def3fbb4850a67ea89">BufferPolicy</a>&#160;</td>
          <td class="paramname"><em>policy</em> = <code><a class="el" href="namespacefkie__message__filters.html#aa9578ad344a317def3fbb4850a67ea89ad94b42030b9785fd754d5c1754961269">BufferPolicy::Discard</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>max_queue_size</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ros::CallbackQueueInterface *&#160;</td>
          <td class="paramname"><em>cbq</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<ul>
<li><code>policy</code> the buffer policy </li>
<li><code>max_queue_size</code> for the <a class="el" href="namespacefkie__message__filters.html#aa9578ad344a317def3fbb4850a67ea89a722ad2d05ecf4868b00c5484b82fd808" title="Queue for later use. ">BufferPolicy::Queue</a> policy, the maximum number of queued data items. </li>
<li><code>cbq</code> ROS callback queue that is used to process queued data</li>
</ul>
<dl class="section user"><dt>Exceptions</dt><dd>Does not throw any exceptions. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classfkie__message__filters_1_1Buffer.html#aa57fd09ab96b5b322ad43c6d2813dc5f" title="Modify the buffer policy. ">set_policy()</a>, <a class="el" href="classfkie__message__filters_1_1Buffer.html#a442730021f44627cd5c7e3ea05a0d7d5" title="Process data with a ROS callback queue. ">set_callback_queue()</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a1a831b68e0dfab4aa7164f2281ae566b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a831b68e0dfab4aa7164f2281ae566b">&#9670;&nbsp;</a></span>connect_to_sink()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacefkie__message__filters.html#a3df68948f3719ec5ab09f1191fc89a7b">Connection</a> <a class="el" href="classfkie__message__filters_1_1Source.html">fkie_message_filters::Source</a>&lt; Outputs &gt;::connect_to_sink </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfkie__message__filters_1_1Sink.html">Sink</a>&lt; Outputs... &gt; &amp;&#160;</td>
          <td class="paramname"><em>dst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Connect this source to a sink. </p>
<p>Can be called multiple times to connect multiple sinks; in that case, the sinks receive data in the same order as they have been connected. This function does basically the same thing as <a class="el" href="classfkie__message__filters_1_1Sink.html#ab6f66493ea85a32a0c44f33d7a51974e" title="Connect this sink to a source. ">Sink::connect_to_source()</a>, only from the opposite point of view.</p>
<ul>
<li><code>dst</code> the sink that is to be connected</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>a connection object that can be used to monitor or sever the created connection</dd></dl>
<dl class="section user"><dt>Exceptions</dt><dd>Does not throw any exceptions. </dd></dl>

</div>
</div>
<a id="ab6f66493ea85a32a0c44f33d7a51974e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6f66493ea85a32a0c44f33d7a51974e">&#9670;&nbsp;</a></span>connect_to_source()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Inputs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacefkie__message__filters.html#a3df68948f3719ec5ab09f1191fc89a7b">Connection</a> <a class="el" href="classfkie__message__filters_1_1Sink.html">fkie_message_filters::Sink</a>&lt; Inputs &gt;::connect_to_source </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfkie__message__filters_1_1Source.html">Source</a>&lt; Inputs... &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Connect this sink to a source. </p>
<p>Can be called multiple times to connect multiple sources; in that case, the sink receives data from all connected sources. This function does basically the same thing as <a class="el" href="classfkie__message__filters_1_1Source.html#a1a831b68e0dfab4aa7164f2281ae566b" title="Connect this source to a sink. ">Source::connect_to_sink()</a>, only from the opposite point of view.</p>
<ul>
<li><code>src</code> the source that is to be connected</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>a connection object that can be used to monitor or sever the created connection </dd></dl>
<dl class="section user"><dt>Exceptions</dt><dd>Does not throw any exceptions. </dd></dl>

</div>
</div>
<a id="add3cbfc888cca3b41a7236f5c314fc43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add3cbfc888cca3b41a7236f5c314fc43">&#9670;&nbsp;</a></span>disconnect_from_all_sinks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classfkie__message__filters_1_1Source.html">fkie_message_filters::Source</a>&lt; Outputs &gt;::disconnect_from_all_sinks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disconnect from all connected sinks. </p>
<p>Severs the connection to all sinks, turning the <a class="el" href="classfkie__message__filters_1_1Source.html#a506e87b830bb228995e42f72a4daf5d9" title="Pass data to all connected sinks. ">send()</a> method into a no-op.</p>
<dl class="section user"><dt>Exceptions</dt><dd>Does not throw any exceptions. </dd></dl>

</div>
</div>
<a id="ac2c8d910b03662ff68a4a1c9b4be4147"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2c8d910b03662ff68a4a1c9b4be4147">&#9670;&nbsp;</a></span>disconnect_from_all_sources()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Inputs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classfkie__message__filters_1_1Sink.html">fkie_message_filters::Sink</a>&lt; Inputs &gt;::disconnect_from_all_sources </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disconnect from all connected sources. </p>
<p>Severs the connection to all sources. The <a class="el" href="classfkie__message__filters_1_1Buffer.html#a0c92512a4e975c949255eada0ce387c2" title="Process incoming data. ">receive()</a> method will not be called any more.</p>
<dl class="section user"><dt>Exceptions</dt><dd>Does not throw any exceptions. </dd></dl>

</div>
</div>
<a id="a61d7ea782d7d4390f7b6ae4fecc4ecde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61d7ea782d7d4390f7b6ae4fecc4ecde">&#9670;&nbsp;</a></span>has_some()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... Inputs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classfkie__message__filters_1_1Buffer.html">fkie_message_filters::Buffer</a>&lt; Inputs &gt;::has_some </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the buffer has pending data. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if the current policy is <a class="el" href="namespacefkie__message__filters.html#aa9578ad344a317def3fbb4850a67ea89a722ad2d05ecf4868b00c5484b82fd808" title="Queue for later use. ">BufferPolicy::Queue</a> and a subsequent call to <a class="el" href="classfkie__message__filters_1_1Buffer.html#a7d40121fca917642f806117b4b5ef6ca" title="Wait for and process one data item. ">process_one()</a> or <a class="el" href="classfkie__message__filters_1_1Buffer.html#afbabc3c79481b303af00f348c760bba1" title="Process pending data. ">spin_once()</a> will process data. </td></tr>
    <tr><td class="paramname">false</td><td>otherwise</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Exceptions</dt><dd>Does not throw any exceptions. </dd></dl>

</div>
</div>
<a id="a7d40121fca917642f806117b4b5ef6ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d40121fca917642f806117b4b5ef6ca">&#9670;&nbsp;</a></span>process_one() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... Inputs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classfkie__message__filters_1_1Buffer.html">fkie_message_filters::Buffer</a>&lt; Inputs &gt;::process_one </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait for and process one data item. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>data has been processed successfully </td></tr>
    <tr><td class="paramname">false</td><td>either the current buffer policy is not <a class="el" href="namespacefkie__message__filters.html#aa9578ad344a317def3fbb4850a67ea89a722ad2d05ecf4868b00c5484b82fd808" title="Queue for later use. ">BufferPolicy::Queue</a>, or the policy has been changed to something other than <a class="el" href="namespacefkie__message__filters.html#aa9578ad344a317def3fbb4850a67ea89a722ad2d05ecf4868b00c5484b82fd808" title="Queue for later use. ">BufferPolicy::Queue</a> while the function was waiting, or the ROS node has been shut down.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Exceptions</dt><dd>Does not throw any exceptions, but will propagate uncaught exceptions from filter callbacks. </dd></dl>

</div>
</div>
<a id="acac65c45b3ac0413e3f21d5a293b1331"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acac65c45b3ac0413e3f21d5a293b1331">&#9670;&nbsp;</a></span>process_one() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... Inputs&gt; </div>
<div class="memtemplate">
template&lt;class Rep , class Period &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classfkie__message__filters_1_1Buffer.html">fkie_message_filters::Buffer</a>&lt; Inputs &gt;::process_one </td>
          <td>(</td>
          <td class="paramtype">const std::chrono::duration&lt; Rep, Period &gt; &amp;&#160;</td>
          <td class="paramname"><em>timeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait for and process one data item. </p>
<ul>
<li><code>timeout</code> maximum duration to wait for new data if none is available</li>
</ul>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>data has been processed successfully </td></tr>
    <tr><td class="paramname">false</td><td>either the current buffer policy is not <a class="el" href="namespacefkie__message__filters.html#aa9578ad344a317def3fbb4850a67ea89a722ad2d05ecf4868b00c5484b82fd808" title="Queue for later use. ">BufferPolicy::Queue</a>, or the policy has been changed to something other than <a class="el" href="namespacefkie__message__filters.html#aa9578ad344a317def3fbb4850a67ea89a722ad2d05ecf4868b00c5484b82fd808" title="Queue for later use. ">BufferPolicy::Queue</a> while the function was waiting, or time timeout expired, or the ROS node has been shut down.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Exceptions</dt><dd>Does not throw any exceptions, but will propagate uncaught exceptions from filter callbacks. </dd></dl>

</div>
</div>
<a id="a0c92512a4e975c949255eada0ce387c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c92512a4e975c949255eada0ce387c2">&#9670;&nbsp;</a></span>receive()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... Inputs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classfkie__message__filters_1_1Buffer.html">fkie_message_filters::Buffer</a>&lt; Inputs &gt;::receive </td>
          <td>(</td>
          <td class="paramtype">const Inputs &amp;...&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Process incoming data. </p>
<p>Derived classes need to override this method to handle all data that is to be consumed by the sink.</p>
<dl class="section user"><dt>Exceptions</dt><dd>Depends on the implementation. </dd></dl>

<p>Implements <a class="el" href="classfkie__message__filters_1_1Sink.html#a10476274ee6189356de12858eff64d83">fkie_message_filters::Sink&lt; Inputs &gt;</a>.</p>

</div>
</div>
<a id="a55b6e088784aa02b6efec16ad1348955"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55b6e088784aa02b6efec16ad1348955">&#9670;&nbsp;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... Inputs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classfkie__message__filters_1_1Buffer.html">fkie_message_filters::Buffer</a>&lt; Inputs &gt;::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset filter. </p>
<p>If the buffer policy is <a class="el" href="namespacefkie__message__filters.html#aa9578ad344a317def3fbb4850a67ea89a722ad2d05ecf4868b00c5484b82fd808" title="Queue for later use. ">BufferPolicy::Queue</a>, this will clear the internal queue and discard all pending data. Otherwise, this function has no effect.</p>
<dl class="section user"><dt>Exceptions</dt><dd>Does not throw any exceptions. </dd></dl>

<p>Reimplemented from <a class="el" href="classfkie__message__filters_1_1FilterBase.html#a39819645172a4a9047b7f82098377db6">fkie_message_filters::FilterBase</a>.</p>

</div>
</div>
<a id="a506e87b830bb228995e42f72a4daf5d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a506e87b830bb228995e42f72a4daf5d9">&#9670;&nbsp;</a></span>send()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classfkie__message__filters_1_1Source.html">fkie_message_filters::Source</a>&lt; Outputs &gt;::send </td>
          <td>(</td>
          <td class="paramtype">const Outputs &amp;...&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pass data to all connected sinks. </p>
<ul>
<li><code>out</code> data</li>
</ul>
<dl class="section user"><dt>Exceptions</dt><dd>Does not throw any exceptions, but will propagate uncaught exceptions from filter callbacks. </dd></dl>

</div>
</div>
<a id="a442730021f44627cd5c7e3ea05a0d7d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a442730021f44627cd5c7e3ea05a0d7d5">&#9670;&nbsp;</a></span>set_callback_queue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... Inputs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classfkie__message__filters_1_1Buffer.html">fkie_message_filters::Buffer</a>&lt; Inputs &gt;::set_callback_queue </td>
          <td>(</td>
          <td class="paramtype">ros::CallbackQueueInterface *&#160;</td>
          <td class="paramname"><em>cbq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Process data with a ROS callback queue. </p>
<p>Instead of running your own processing threads, you can use the ROS callback system to schedule data processing whenever new data arrives.</p>
<ul>
<li><code>cbq</code> the ROS callback queue or <code>nullptr</code> to disable ROS callbacks.</li>
</ul>
<dl class="section user"><dt>Exceptions</dt><dd>Does not throw any exceptions.</dd></dl>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>mf = <a class="code" href="namespacefkie__message__filters.html">fkie_message_filters</a>;</div><div class="line"></div><div class="line">mf::Buffer&lt;...&gt; buf;</div><div class="line"></div><div class="line">buf.set_callback_queue(ros::getGlobalCallbackQueue());</div><div class="line">ros::spin();</div></div><!-- fragment --> 
</div>
</div>
<a id="aa57fd09ab96b5b322ad43c6d2813dc5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa57fd09ab96b5b322ad43c6d2813dc5f">&#9670;&nbsp;</a></span>set_policy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... Inputs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classfkie__message__filters_1_1Buffer.html">fkie_message_filters::Buffer</a>&lt; Inputs &gt;::set_policy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacefkie__message__filters.html#aa9578ad344a317def3fbb4850a67ea89">BufferPolicy</a>&#160;</td>
          <td class="paramname"><em>policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>max_queue_size</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modify the buffer policy. </p>
<p>If the new buffer policy is not <a class="el" href="namespacefkie__message__filters.html#aa9578ad344a317def3fbb4850a67ea89a722ad2d05ecf4868b00c5484b82fd808" title="Queue for later use. ">BufferPolicy::Queue</a>, any pending call to <a class="el" href="classfkie__message__filters_1_1Buffer.html#a08a7892ed0a8602685fb6453be134ac6" title="Wait for pending data. ">wait()</a>, <a class="el" href="classfkie__message__filters_1_1Buffer.html#a7d40121fca917642f806117b4b5ef6ca" title="Wait for and process one data item. ">process_one()</a>, or <a class="el" href="classfkie__message__filters_1_1Buffer.html#a4e73957be1c2d7f2223206d189d8669f" title="Process all data indefinitely. ">spin()</a> will return. If the buffer policy is changed to <a class="el" href="namespacefkie__message__filters.html#aa9578ad344a317def3fbb4850a67ea89ac3e72e91fe05fe792fa27eea830ec68f" title="Forward data immediately. ">BufferPolicy::Passthru</a>, all pending data is processed immediately before the function returns. If the buffer policy is changed to <a class="el" href="namespacefkie__message__filters.html#aa9578ad344a317def3fbb4850a67ea89ad94b42030b9785fd754d5c1754961269" title="Discard all data. ">BufferPolicy::Discard</a>, all pending data is discarded immediately.</p>
<ul>
<li><code>policy</code> the buffer policy </li>
<li><code>max_queue_size</code> for the <a class="el" href="namespacefkie__message__filters.html#aa9578ad344a317def3fbb4850a67ea89a722ad2d05ecf4868b00c5484b82fd808" title="Queue for later use. ">BufferPolicy::Queue</a> policy, the maximum number of queued data items. If zero, the previously set queue size remains unchanged.</li>
</ul>
<dl class="section warning"><dt>Warning</dt><dd>If you change the policy from <a class="el" href="namespacefkie__message__filters.html#aa9578ad344a317def3fbb4850a67ea89a722ad2d05ecf4868b00c5484b82fd808" title="Queue for later use. ">BufferPolicy::Queue</a> to <a class="el" href="namespacefkie__message__filters.html#aa9578ad344a317def3fbb4850a67ea89ac3e72e91fe05fe792fa27eea830ec68f" title="Forward data immediately. ">BufferPolicy::Passthru</a> and there is still a pending call to <a class="el" href="classfkie__message__filters_1_1Buffer.html#a7d40121fca917642f806117b4b5ef6ca" title="Wait for and process one data item. ">process_one()</a>, <a class="el" href="classfkie__message__filters_1_1Buffer.html#afbabc3c79481b303af00f348c760bba1" title="Process pending data. ">spin_once()</a>, or <a class="el" href="classfkie__message__filters_1_1Buffer.html#a4e73957be1c2d7f2223206d189d8669f" title="Process all data indefinitely. ">spin()</a> in a different thread, some data might be processed in parallel or out of order when the queue is flushed.</dd></dl>
<dl class="section user"><dt>Exceptions</dt><dd>Does not throw any exceptions, but will propagate uncaught exceptions from filter callbacks. </dd></dl>

</div>
</div>
<a id="a4e73957be1c2d7f2223206d189d8669f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e73957be1c2d7f2223206d189d8669f">&#9670;&nbsp;</a></span>spin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... Inputs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classfkie__message__filters_1_1Buffer.html">fkie_message_filters::Buffer</a>&lt; Inputs &gt;::spin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Process all data indefinitely. </p>
<p>Blocks and processes all incoming data until the buffer policy is changed to something other than <a class="el" href="namespacefkie__message__filters.html#aa9578ad344a317def3fbb4850a67ea89a722ad2d05ecf4868b00c5484b82fd808" title="Queue for later use. ">BufferPolicy::Queue</a> or the ROS node is shut down.</p>
<p>You can call the function from multiple threads at once, and the workload will be shared among all participating threads.</p>
<dl class="section user"><dt>Exceptions</dt><dd>Does not throw any exceptions, but will propagate uncaught exceptions from filter callbacks. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classfkie__message__filters_1_1Buffer.html#aa57fd09ab96b5b322ad43c6d2813dc5f" title="Modify the buffer policy. ">set_policy()</a> </dd></dl>

</div>
</div>
<a id="afbabc3c79481b303af00f348c760bba1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbabc3c79481b303af00f348c760bba1">&#9670;&nbsp;</a></span>spin_once()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... Inputs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classfkie__message__filters_1_1Buffer.html">fkie_message_filters::Buffer</a>&lt; Inputs &gt;::spin_once </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Process pending data. </p>
<p>Does nothing if the buffer policy is not <a class="el" href="namespacefkie__message__filters.html#aa9578ad344a317def3fbb4850a67ea89a722ad2d05ecf4868b00c5484b82fd808" title="Queue for later use. ">BufferPolicy::Queue</a>. The method is guaranteed to return as it will only process data which is pending at invocation time. This also means that there may be new data pending already when this method returns.</p>
<dl class="section user"><dt>Exceptions</dt><dd>Does not throw any exceptions, but will propagate uncaught exceptions from filter callbacks. </dd></dl>

</div>
</div>
<a id="a08a7892ed0a8602685fb6453be134ac6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08a7892ed0a8602685fb6453be134ac6">&#9670;&nbsp;</a></span>wait()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... Inputs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classfkie__message__filters_1_1Buffer.html">fkie_message_filters::Buffer</a>&lt; Inputs &gt;::wait </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wait for pending data. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>there is data available for consumption by <a class="el" href="classfkie__message__filters_1_1Buffer.html#afbabc3c79481b303af00f348c760bba1" title="Process pending data. ">spin_once()</a> </td></tr>
    <tr><td class="paramname">false</td><td>either the current buffer policy is not <a class="el" href="namespacefkie__message__filters.html#aa9578ad344a317def3fbb4850a67ea89a722ad2d05ecf4868b00c5484b82fd808" title="Queue for later use. ">BufferPolicy::Queue</a>, or the policy has been changed to something other than <a class="el" href="namespacefkie__message__filters.html#aa9578ad344a317def3fbb4850a67ea89a722ad2d05ecf4868b00c5484b82fd808" title="Queue for later use. ">BufferPolicy::Queue</a> while the function was waiting, or the ROS node has been shut down.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Exceptions</dt><dd>Does not throw any exceptions. </dd></dl>

</div>
</div>
<a id="adde77088d53cd1d6de70840e10532658"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adde77088d53cd1d6de70840e10532658">&#9670;&nbsp;</a></span>wait_for()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... Inputs&gt; </div>
<div class="memtemplate">
template&lt;class Rep , class Period &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classfkie__message__filters_1_1Buffer.html">fkie_message_filters::Buffer</a>&lt; Inputs &gt;::wait_for </td>
          <td>(</td>
          <td class="paramtype">const std::chrono::duration&lt; Rep, Period &gt; &amp;&#160;</td>
          <td class="paramname"><em>timeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wait for pending data until timeout expires. </p>
<ul>
<li><code>timeout</code> maximum duration to wait for new data if none is available</li>
</ul>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>there is data available for consumption by <a class="el" href="classfkie__message__filters_1_1Buffer.html#afbabc3c79481b303af00f348c760bba1" title="Process pending data. ">spin_once()</a> </td></tr>
    <tr><td class="paramname">false</td><td>either the current buffer policy is not <a class="el" href="namespacefkie__message__filters.html#aa9578ad344a317def3fbb4850a67ea89a722ad2d05ecf4868b00c5484b82fd808" title="Queue for later use. ">BufferPolicy::Queue</a>, or the policy has been changed to something other than <a class="el" href="namespacefkie__message__filters.html#aa9578ad344a317def3fbb4850a67ea89a722ad2d05ecf4868b00c5484b82fd808" title="Queue for later use. ">BufferPolicy::Queue</a> while the function was waiting, or the timeout expired, or the ROS node has been shut down.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Exceptions</dt><dd>Does not throw any exceptions. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/fkie_message_filters/buffer.h</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
